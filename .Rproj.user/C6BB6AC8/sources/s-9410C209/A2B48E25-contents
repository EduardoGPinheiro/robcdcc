'Estimate and calculate portfÃ³lio variance.'
# Packages
library(dplyr)
library(ggplot2)
library(rlist)
library(Metrics) # RMSE
library(purrr)
library(readr)
library(tidyr) # pivot_wider
library(data.table)
library(lemon) # shared subtitle for grid.arrange
library(miceadds) # source.all
library(Rcpp)
library(RcppArmadillo)
library(parallel)
library(robcdcc)
library(nlshrink)

# Paths
setwd('/home/encrypted/epinheiro/Documentos')

# Functions
source('packages.R')

# Paths, parameters & attributes - delta equals 0.95...
phi = c(.1, .8)
nobs = 1250
ndim = 1000
count = 0

my_nlshrink = function(data){
  S = NA
  tryCatch({
    S = nlshrink_cov(data, method='nloptr') %>% cov2cor
  }, error = function(e){cat("ERROR :",
                             conditionMessage(e))})
  return(S)
}

repCDCC_H = function(nobs, ndim, epsilon=0, d=0, consecutive=FALSE){
  # Starting workers
  cores = detectCores() # detecting number of cores in the PC
  cl = makeCluster(cores-2)
  
  clusterExport(cl, c("rtruncnorm", "high_dimension_simCDCC", 
                      "simCDCC_C", "burnin_high_dimension_simCDCC"))
  clusterExport(cl, c("high_dimension_estimateCDCC", 
                      "optimCDCC", 
                      "loglikelihoodCDCC",
                      "gradientCDCC", 
                      "robust_optimCDCC",
                      "robust_loglikelihoodCDCC",
                      "robust_gradientCDCC"
  ))
  clusterExport(cl, c("linshrink_cov", "nlshrink_cov", "my_nlshrink", "%>%",
                      "calc_portfolio_variance", 
                      "geral_calc_portfolio_variance",
                      "robust_calc_portfolio_variance"))
  clusterExport(cl, c('phi', "nobs", "ndim"), envir = environment())
  
  # Simulation
  for(i in 1:10){
    tryCatch({
      cat('\n', 'pt ', i, '\n')
      print(Sys.time())
      
      data_path = paste(
        'simulation_results/high_dimension_simulation_n1250/pt_', i, '.Rds', 
        sep = "")
      sim = readRDS(data_path)
      data = map(sim, 1)
      seeds = map(sim, 2)
      
      burnin_path = paste(
        'simulation_results/burnin_high_dimension_simulation_n1250/pt_', i, '.Rds', 
        sep = "")
      
      burnin_data = readRDS(burnin_path)
      bdata = map(burnin_data, 1)
      bseeds = map(burnin_data, 2)
      
      all_data = lapply(1:10, function(x){
        rbind(bdata[[x]], data[[x]])
      })
      
      # Validating
      validate_burnin = all_data %>% lapply(anyDuplicated) %>% unlist
      
      if(all(validate_burnin == 102) == FALSE){
        print('burnin sample incompatible!')
        break
      }
      
      # contaminating data
      cont_seed = as.list(((i * 10 + 1) : (i * 10  + 10)))
      cont_data = mapply(contaminate_high1, data, cont_seed, 
                         MoreArgs = list(d=d, epsilon=epsilon,
                                         consecutive=consecutive), 
                         SIMPLIFY = FALSE)
      
      # Estimate 
      print(Sys.time())
      cat('\n', 'standart estimation!', '\n')
      
      estimates = parLapply(
        cl = cl,
        cont_data,
        high_dimension_estimateCDCC
      )
      
      print(Sys.time())
      cat('\n', 'robust estimation!', '\n')
      robust_estimates = parLapply(
        cl = cl,
        cont_data,
        high_dimension_robust_estimateCDCC
      )
      
      estimates_df = estimates %>% rlist::list.rbind(.) %>% data.frame
      robust_estimates_df = robust_estimates %>% rlist::list.rbind(.) %>%
        data.frame
      
      estimates_df$model = 'Q'
      robust_estimates_df$model = 'R'
      
      final_df = rbind(estimates_df, robust_estimates_df)
      final_df$epsilon = epsilon
      final_df$d = d
      final_df$seed = i
      
      cat('\n', 'salvando resultados')
      print(Sys.time())
      
      results_path = paste(
        'simulation_results/high_dimension_estimates_n1250_alt/pt_', i,
        '_epsilon_', epsilon, '_d_', d, '_consecutive_', 
        consecutive,'.Rds', sep = "")
      
      # checkpoint
      saveRDS(final_df, file = results_path)
      
      # Portfolio variance 
      # Robust config 
      robust_control = c(1.0465, 1.00045, .975)
      cy1 = robust_control[1]
      cy2 = robust_control[2]
      delta = robust_control[3]
      
      # quantile for chi square distribution
      chisq1 = qchisq(delta, 1) 
      chisq2 = qchisq(delta, ndim)
      
      # Calculating all Qs * epsilon 
      q_Qs = mapply(calc_Qs, estimates, cont_data, SIMPLIFY = FALSE)
      r_Qs = mapply(robust_calc_Qs, robust_estimates, cont_data, 
                    MoreArgs = list(cy1 = cy1, chisq1 = chisq1), 
                    SIMPLIFY = FALSE)
      
      # Getting real S 
      S = lapply(seeds, function(x){
        set.seed(x * 10)
        rho = rtruncnorm(
          ndim,
          a = .5 - 4 * .1,
          b = .5 + 4 * .1,
          mean = .5,
          sd = .1
        )
        S = rho %o% rho
        diag(S) = rep(1, ndim)
        
        return(S)
      })
      
      # Non-Linear Shrinkage covariance estimate
      print(Sys.time())
      cat('\n', 'shrinkage!', '\n')
      
      q_S = parLapply(cl=cl, q_Qs, my_nlshrink)
      r_S = parLapply(cl=cl, r_Qs, my_nlshrink)
      
      cat('\n', 'S determinant!', '\n')
      q_S_determinant =  q_S %>% lapply(determinant) %>%
        map(1) %>% lapply(function(x){return(x[1])}) %>%
        unlist
      r_S_determinant =  r_S %>% lapply(determinant) %>%
        map(1) %>% lapply(function(x){return(x[1])}) %>%
        unlist
      
      # Portfolio variance 
      print(Sys.time())
      cat('\n', 'portfolio_var!', '\n')
      
      variance_portfolio = parLapply(
        cl = cl,
        1:10,
        fun=function(x){
          tryCatch(
            geral_calc_portfolio_variance(phi=phi, 
                                          q_phi=estimates[[x]], 
                                          r_phi=robust_estimates[[x]], 
                                          rt=data[[x]], burn_rt=bdata[[x]],
                                          cont_rt=cont_data[[x]],
                                          S=S[[x]], 
                                          q_S=q_S[[x]], r_S=r_S[[x]],
                                          cy2=cy2, chisq2=chisq2)
          )}
      ) 
      
      results = lapply(variance_portfolio, t) %>% 
        rlist::list.rbind(.) %>% as.data.frame
      results$q_S_determinant = q_S_determinant
      results$r_S_determinant = r_S_determinant
      results$d = d
      results$consecutive = consecutive
      results$epsilon = epsilon
      
      # biding results 
      results_path = paste(
        'simulation_results/high_dimension_var_n1250_alt/pt_', i, '_epsilon_', 
        epsilon, '_d_', d, '_consecutive_', consecutive,'.Rds', sep = "")
      
      # checkpoint
      saveRDS(results, file = results_path)
    }, error = function(e){cat("ERROR :",
                               conditionMessage(e), '. iteration:', i, "\n")})
    
  }
  stopCluster(cl)
}

# repCDCC_H(nobs=nobs, ndim=ndim)
# repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.25, d=5)
repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.25, d=5, consecutive = TRUE)

# repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.25, d=10)
# repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.25, d=10, consecutive = TRUE)

repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.5, d=5)
repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.5, d=5, consecutive = TRUE)

repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.5, d=10)
repCDCC_H(nobs=nobs, ndim=ndim, epsilon=0.5, d=10, consecutive = TRUE)

