# Auxiliary functions for estimation based on list of data
# QML approach
estimatecDCC_by_list = function(data_list){
  estimate = lapply(data_list, estimateCDCC)
  eta_hat = map(estimate, 1) %>% rlist::list.rbind(.)
  phi_hat = map(estimate, 2) %>% rlist::list.rbind(.)
  
  return(list(eta=eta_hat, phi=phi_hat))
}

# Robust approach
robust_estimatecDCC_by_list = function(data_list, robust_control){
  estimate = lapply(data_list, robust_estimateCDCC, robust_control)
  eta_hat = map(estimate, 1) %>% rlist::list.rbind(.)
  phi_hat = map(estimate, 2) %>% rlist::list.rbind(.)
  
  return(list(eta=eta_hat, phi=phi_hat))
}


#------------------------------------------------------------------------------#
repCDCC = function(phi, eta, replica, nobs, ndim, outlier, estimation, 
                   filename){
  
  checkpoint = i = 1
  cores = detectCores() # detecting number of cores in the PC
  cl = makeCluster(cores-2)
  est_eta = est_phi = c() # stores estimates for each iteration
  
  # setting clusters for parallel
  clusterExport(cl, c("simCDCC", 
                      'contaminate1', 
                      'rtruncnorm', 
                      'rmvn',
                      'map', 
                      '%>%'))
  
  clusterExport(cl, c('phi', 
                      'eta', 
                      'S', 
                      'nobs',
                      'ndim', 
                      'outlier', 
                      'i'), envir = environment())
  
  if(estimation == 'standart'){
    
    cat('\n', 'standart estimation!!', '\n')
    
    # index
    d_index = rep(rep(c(0, 3, 4, 3, 4, 3, 4), each=10), floor(replica/10))
    
    epsilon_index = rep(rep(c('0%', '1%', '1%', '5%', '5%', '10%', '10%'), 
                            each=10), floor(replica/10)) %>% 
      factor(., levels = c("0%", "1%", "5%", "10%"))
    
    # reserving spaces for the estimates
    NAs_for_eta = matrix(NA, ncol = nrow(eta) * 5, nrow = length(d_index))
    NAs_for_phi = matrix(NA, ncol = length(phi), nrow = length(d_index))
    
    # dataframe of results
    estimates_for_eta = data.frame(epsilon_index, d_index,
                                   NAs_for_eta) # stores all estimates for eta
    
    estimates_for_phi = data.frame(epsilon_index, d_index, 
                                   NAs_for_phi) # stores all estimates for phi
    
    for(i in 1:floor(replica/10)){
      # Monte Carlo simulation
      sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCC(phi, 
                                                             eta, 
                                                             S, 
                                                             nobs, 
                                                             ndim, 
                                                             x + i*20
                                                             )})
      
      # taking rt and ht from sim
      rt = map(sim, 1)
      ht = map(sim, 2)
      
      # contaminatinc series of returns
      seed = as.list(sqrt((i * 10 + 1) : (i * 10  + 10)))
      
      rt_list = list(mapply(contaminate1, rt, ht, seed, nday=0, 0, 
                            SIMPLIFY = FALSE), # epsilon=0%
                     mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 3,
                            SIMPLIFY = FALSE),  # epsilon=1%
                     mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 4,
                            SIMPLIFY = FALSE),  # epsilon=1%
                     mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 3,
                            SIMPLIFY = FALSE),  # epsilon=5%
                     mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 4,
                            SIMPLIFY = FALSE),   # epsilon=5%
                     mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 3,
                            SIMPLIFY = FALSE),   # epsilon=5%
                     mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4,
                            SIMPLIFY = FALSE)   # epsilon=5%
      )
      
      # estimation
      estimated = lapply(rt_list, estimatecDCC_by_list)
      
      est_eta = map(estimated, 1) %>% list.rbind(.) 
      est_phi = map(estimated, 2) %>% list.rbind(.) 
      
      # updating dataframe of all estimates
      index_for_update = ((i-1) * 70 + 1) : (i * 70)
      
      estimates_for_eta[index_for_update, -c(1,2)] = est_eta
      estimates_for_phi[index_for_update, -c(1,2)] = est_phi
      
      # checkpoint
      saveRDS(estimates_for_eta, file = filename[1])
      saveRDS(estimates_for_phi, file = filename[2])
      
      
      checkpoint = (i * 10) / replica * 100
      
      cat('\n', 'progress in ', checkpoint, '%', '\n')
      print(Sys.time())
      
    }
  }
  
  if(estimation == 'robust'){
    
    cat('\n', 'robust estimation!!', '\n')
    
    # index
    delta_index = rep(rep(c(0.99, 0.975, 0.95, 0.90), each = 70), 
                      floor(replica/10))
    
    d_index = rep(rep(rep(c(0, 3, 4, 3, 4, 3, 4), each=10), 4), 
                  floor(replica/10))
    
    epsilon_index = rep(rep(rep(c('0%', '1%', '1%', '5%', '5%', '10%', '10%'), 
                                each=10), 4), floor(replica/10)) %>% 
      factor(., levels = c("0%", "1%", "5%", "10%"))
    
    # reserving spaces for the estimates
    NAs_for_eta = matrix(NA, ncol = nrow(eta) * 5, nrow = length(delta_index))
    NAs_for_phi = matrix(NA, ncol = length(phi), nrow = length(delta_index))
    
    # dataframe of results
    estimates_for_eta = data.frame(epsilon_index, d_index, delta_index,
                                   NAs_for_eta) # stores all estimates for eta
    
    estimates_for_phi = data.frame(epsilon_index, d_index, delta_index, 
                                   NAs_for_phi) # stores all estimates for phi
    
    for(i in 1:floor(replica/10)){
      tryCatch({
        # Monte Carlo simulation
        sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCC(phi, eta, S, 
                                                               nobs, 
                                                               ndim, 
                                                               x + i * 20
                                                               )})
        
        # taking rt and ht from sim
        rt = map(sim, 1)
        ht = map(sim, 2)
        
        # contaminating series of returns
        seed = as.list(sqrt((i * 10+1) : (i * 10  + 10)))
        
        rt_list = list(mapply(contaminate1, rt, ht, seed, nday=0, 0,
                              SIMPLIFY = FALSE), # epsilon=0%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 3,
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 4, 
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 3, 
                              SIMPLIFY = FALSE),  # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 4, 
                              SIMPLIFY = FALSE),   # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 3, 
                              SIMPLIFY = FALSE),   # epsilon=10%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4, 
                              SIMPLIFY = FALSE)   # epsilon=10%
        )
        
        # estimation
        # setting robust control
        rc_delta99 = c(1.0185, 1.0101, .99)
        rc_delta975 = c(1.0465, 1.0257, .975)
        rc_delta95 = c(1.0953, 1.0526, .95)
        rc_delta90 = c(1.2030, 1.111, .90)
        
        # estimating for all replicas
        estimated_delta99 = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta99)
        
        estimated_delta975 = lapply(rt_list, 
                                    robust_estimatecDCC_by_list, 
                                    rc_delta975)
        
        estimated_delta95 = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta95)
        
        estimated_delta90 = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta90)
        
        # storing estimates of this iteration
        est_eta = c(map(estimated_delta99, 1),
                    map(estimated_delta975, 1),
                    map(estimated_delta95, 1),
                    map(estimated_delta90, 1)) %>% list.rbind(.) 
        
        est_phi = c(map(estimated_delta99, 2),
                    map(estimated_delta975, 2),
                    map(estimated_delta95, 2),
                    map(estimated_delta90, 2)) %>% list.rbind(.)
        
        # updating dataframe of all estimates
        index_for_update = ((i-1) * 280 + 1) : (i * 280)
        
        estimates_for_eta[index_for_update, -c(1,2,3)] = est_eta
        estimates_for_phi[index_for_update, -c(1,2,3)] = est_phi
        
        # checkpoint
        saveRDS(estimates_for_eta, file = filename[1])
        saveRDS(estimates_for_phi, file = filename[2])
        
        checkpoint = (i * 10) / replica * 100
        
        cat('\n', 'progress in ', checkpoint, '%', '\n')
        print(Sys.time())
      }, error = function(e){cat("ERROR :", 
                                 conditionMessage(e), '. iteration:', i, "\n")})
    }
  }
  
  stopCluster(cl)
  
  return(print('The End!'))
} 

#------------------------------------------------------------------------------#
repCDCC_plus = function(phi, eta, replica, nobs, ndim, outlier, estimation, 
                        filename){
  
  checkpoint = i = 0
  cores = detectCores() # detecting number of cores in the PC
  cl = makeCluster(cores-2)
  est_eta = est_phi = c() # stores estimates for each iteraction
  
  # setting clusters for parallel
  clusterExport(cl, c("simCDCC", 
                      'contaminate1', 
                      'rtruncnorm', 
                      'rmvn', 
                      'map', 
                      '%>%'))
  
  clusterExport(cl, c('phi', 
                      'eta', 
                      'S', 
                      'nobs',
                      'ndim', 
                      'outlier', 
                      'i'), envir = environment())
  
  if(estimation == 'standart'){
    
    cat('\n', 'standart estimation!!', '\n')
    
    
    for(i in 1:floor(replica/10)){
      # Monte Carlo simulation
      sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCC(phi, 
                                                             eta, 
                                                             S, 
                                                             nobs, 
                                                             ndim, 
                                                             x + i*20, 
                                                             outlier, 
                                                             nday, 
                                                             d)})
      
      # taking rt and ht from sim
      rt = map(sim, 1)
      ht = map(sim, 2)
      
      # contaminatinc series of returns
      seed = as.list(sqrt((i * 10 + 1) : (i * 10  + 10)))
      
      rt = mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4,
                  SIMPLIFY = FALSE)  # epsilon=10%
      
      
      # estimation
      estimated = lapply(rt, estimateCDCC)
      
      est_eta = map(estimated, 1) %>% list.rbind(.) %>% rbind(., est_eta)
      est_phi = map(estimated, 2) %>% list.rbind(.) %>% rbind(., est_phi)
    
      # checkpoint
      saveRDS(est_eta, file = filename[1])
      saveRDS(est_phi, file = filename[2])
      
      
      checkpoint = (i * 10) / replica * 100
      
      cat('\n', 'progress in ', checkpoint, '%', '\n')
      print(Sys.time())
      
    }
  }
  
  if(estimation == 'robust'){
    
    cat('\n', 'robust estimation!!', '\n')
    
    # index
    delta_index = rep(rep(c('0.99%',
                            '0.975%', 
                            '0.95%', 
                            '0.90%'), times = c(20, 20, 20, 70)), 
                      floor(replica/10))
    
    d_index = rep(rep(c(rep(c(3,4), 3), 0, rep(c(3,4), 3)), each=10), 
                  floor(replica/10))
    
    epsilon_index = rep(rep(c('10%', '0%', '1%', '5%', '10%'), 
                                times=c(60, 10, 20, 20, 20)),
                        floor(replica/10))
    
    # reserving spaces for the estimates
    NAs_for_eta = matrix(NA, ncol = nrow(eta) * 5, nrow = length(delta_index))
    NAs_for_phi = matrix(NA, ncol = length(phi), nrow = length(delta_index))
    
    # dataframe of results
    estimates_for_eta = data.frame(epsilon_index, d_index, delta_index,
                                   NAs_for_eta) # stores all estimates for eta
    
    estimates_for_phi = data.frame(epsilon_index, d_index, delta_index, 
                                   NAs_for_phi) # stores all estimates for phi
    
    for(i in 1:floor(replica/10)){
      tryCatch({
        # Monte Carlo simulation
        sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCC(phi, eta, S, 
                                                               nobs, 
                                                               ndim,
                                                               x + i * 20, 
                                                               outlier, 
                                                               nday, d)})
        
        # taking rt and ht from sim
        rt = map(sim, 1)
        ht = map(sim, 2)
        
        # contaminating series of returns
        seed = as.list(sqrt((i * 10+1) : (i * 10  + 10)))
        
        rt_list = list(mapply(contaminate1, rt, ht, seed, nday=0, 0,
                              SIMPLIFY = FALSE), # epsilon=0%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 3,
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 4, 
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 3, 
                              SIMPLIFY = FALSE),  # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 4, 
                              SIMPLIFY = FALSE),  # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 3, 
                              SIMPLIFY = FALSE),   # epsilon=10%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4, 
                              SIMPLIFY = FALSE)   # epsilon=10%
        )
        
        rt_sublist = rt_list[c(6,7)]
        
        # estimation
        # setting robust control
        rc_delta99 = c(1.0185, 1.0101, .99)
        rc_delta975 = c(1.0465, 1.0257, .975)
        rc_delta95 = c(1.0953, 1.0526, .95)
        rc_delta80 = c(1.2030, 1.111, .90)
        
        # estimating for all replicas
        estimated_delta99 = lapply(rt_sublist, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta99)
        
        estimated_delta975 = lapply(rt_sublist, 
                                    robust_estimatecDCC_by_list, 
                                    rc_delta975)
        
        estimated_delta95 = lapply(rt_sublist, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta95)
        
        estimated_delta90 = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta90)
        
        # storing estimates of this iteration
        est_eta = c(map(estimated_delta99, 1),
                    map(estimated_delta975, 1),
                    map(estimated_delta95, 1),
                    map(estimated_delta90, 1)) %>% list.rbind(.) 
        
        est_phi = c(map(estimated_delta99, 2),
                    map(estimated_delta975, 2),
                    map(estimated_delta95, 2), 
                    map(estimated_delta90, 2)) %>% list.rbind(.)
        
        # updating dataframe of all estimates
        index_for_update = ((i-1) * 130 + 1) : (i * 130)
        
        estimates_for_eta[index_for_update, -c(1,2,3)] = est_eta
        estimates_for_phi[index_for_update, -c(1,2,3)] = est_phi
        
        # checkpoint
        saveRDS(estimates_for_eta, file = filename[1])
        saveRDS(estimates_for_phi, file = filename[2])
        
        checkpoint = (i * 10) / replica * 100
        
        cat('\n', 'progress in ', checkpoint, '%', '\n')
        print(Sys.time())
      }, error = function(e){cat("ERROR :", 
                                 conditionMessage(e), '. iteration:', i, "\n")})
    }
  }
  
  stopCluster(cl)
  
  return(print('The End!'))
}

#-------------------------------------------------------------------------------
repCDCC_unique = function(phi, eta, replica, nobs, ndim, outlier, estimation, 
                        filename){
  
  checkpoint = i = 0
  cores = detectCores() # detecting number of cores in the PC
  cl = makeCluster(cores-2)
  est_eta = est_phi = c() # stores estimates for each iteraction
  
  # setting clusters for parallel
  clusterExport(cl, c("simCDCC", 
                      'contaminate1', 
                      'rtruncnorm', 
                      'rmvn', 
                      'map', 
                      '%>%'))
  
  clusterExport(cl, c('phi', 
                      'eta', 
                      'S', 
                      'nobs',
                      'ndim', 
                      'outlier', 
                      'i'), envir = environment())
  
  if(estimation == 'standart'){
    
    cat('\n', 'standart estimation!!', '\n')
    
    
    for(i in 1:floor(replica/10)){
      # Monte Carlo simulation
      sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCC(phi, 
                                                             eta, 
                                                             S, 
                                                             nobs, 
                                                             ndim, 
                                                             x + i*20
                                                             )})
      
      # taking rt and ht from sim
      rt = map(sim, 1)
      ht = map(sim, 2)
      
      # contaminatinc series of returns
      seed = as.list(sqrt((i * 10 + 1) : (i * 10  + 10)))
      
      rt = mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4,
                  SIMPLIFY = FALSE)  # epsilon=10%
      
      
      # estimation
      estimated = lapply(rt, estimateCDCC)
      
      est_eta = map(estimated, 1) %>% list.rbind(.) %>% rbind(., est_eta)
      est_phi = map(estimated, 2) %>% list.rbind(.) %>% rbind(., est_phi)
      
      # checkpoint
      saveRDS(est_eta, file = filename[1])
      saveRDS(est_phi, file = filename[2])
      
      
      checkpoint = (i * 10) / replica * 100
      
      cat('\n', 'progress in ', checkpoint, '%', '\n')
      print(Sys.time())
      
    }
  }
  
  if(estimation == 'robust'){
    
    cat('\n', 'robust estimation!!', '\n')
    
    # index
    delta_index = rep(rep(c('0.80%'), 70), 
                      floor(replica/10))
    
    d_index = rep(rep(c(0,3,4,3,4,3,4), each=10), floor(replica/10))
    
    epsilon_index = rep(rep(c('0%', '1%', '5%', '10%'), 
                            times=c(10, 20, 20, 20)),
                        floor(replica/10))
    
    # reserving spaces for the estimates
    NAs_for_eta = matrix(NA, ncol = nrow(eta) * 5, nrow = length(delta_index))
    NAs_for_phi = matrix(NA, ncol = length(phi), nrow = length(delta_index))
    
    # dataframe of results
    estimates_for_eta = data.frame(epsilon_index, d_index, delta_index,
                                   NAs_for_eta) # stores all estimates for eta
    
    estimates_for_phi = data.frame(epsilon_index, d_index, delta_index, 
                                   NAs_for_phi) # stores all estimates for phi
    
    for(i in 1:floor(replica/10)){
      tryCatch({
        # Monte Carlo simulation
        sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCC(phi, eta, S, 
                                                               nobs, 
                                                               ndim,
                                                               x + i * 20
                                                               )})
        
        # taking rt and ht from sim
        rt = map(sim, 1)
        ht = map(sim, 2)
        
        # contaminatinc series of returns
        seed = as.list(sqrt((i * 10+1) : (i * 10  + 10)))
        
        rt_list = list(mapply(contaminate1, rt, ht, seed, nday=0, 0,
                              SIMPLIFY = FALSE), # epsilon=0%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 3,
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 4, 
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 3, 
                              SIMPLIFY = FALSE),  # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 4, 
                              SIMPLIFY = FALSE),  # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 3, 
                              SIMPLIFY = FALSE),   # epsilon=10%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4, 
                              SIMPLIFY = FALSE)   # epsilon=10%
        )
        

        # estimation
        # setting robust control
        rc_delta = c(4.979832, 2.480683, .40)
        
        # estimating for all replicas
        estimated_delta = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta)
        
        # storing estimates of this iteration
        est_eta = c(map(estimated_delta, 1)) %>% list.rbind(.) 
        
        est_phi = c(map(estimated_delta, 2)) %>% list.rbind(.)
        
        # updating dataframe of all estimates
        index_for_update = ((i-1) * 70 + 1) : (i * 70)
        
        estimates_for_eta[index_for_update, -c(1,2,3)] = est_eta
        estimates_for_phi[index_for_update, -c(1,2,3)] = est_phi
        
        # checkpoint
        saveRDS(estimates_for_eta, file = filename[1])
        saveRDS(estimates_for_phi, file = filename[2])
        
        checkpoint = (i * 10) / replica * 100
        
        cat('\n', 'progress in ', checkpoint, '%', '\n')
        print(Sys.time())
      }, error = function(e){cat("ERROR :", 
                                 conditionMessage(e), '. iteration:', i, "\n")})
    }
  }
  
  stopCluster(cl)
  
  return(print('The End!'))
}

#------------------------------------------------------------------------------#
repCDCCt = function(phi, eta, replica, nobs, ndim, outlier, estimation, 
                   filename){
  
  checkpoint = i = 1
  cores = detectCores() # detecting number of cores in the PC
  cl = makeCluster(cores-2)
  est_eta = est_phi = c() # stores estimates for each iteration
  
  # setting clusters for parallel
  clusterExport(cl, c("simCDCCt", 
                      'contaminate1', 
                      'rtruncnorm', 
                      'rmvn',
                      'map', 
                      '%>%', 
                      'sqrtm'))
  
  clusterExport(cl, c('phi', 
                      'eta', 
                      'S', 
                      'nobs',
                      'ndim', 
                      'outlier'
                      ), envir = environment())
  
  if(estimation == 'standart'){
    
    cat('\n', 'standart estimation!!', '\n')
    
    # index
    d_index = rep(rep(c(0, 3, 4, 3, 4, 3, 4), each=10), floor(replica/10))
    
    epsilon_index = rep(rep(c('0%', '1%', '1%', '5%', '5%', '10%', '10%'), 
                            each=10), floor(replica/10)) %>% 
      factor(., levels = c("0%", "1%", "5%", "10%"))
    
    # reserving spaces for the estimates
    NAs_for_eta = matrix(NA, ncol = nrow(eta) * 5, nrow = length(d_index))
    NAs_for_phi = matrix(NA, ncol = length(phi), nrow = length(d_index))
    
    # dataframe of results
    estimates_for_eta = data.frame(epsilon_index, d_index,
                                   NAs_for_eta) # stores all estimates for eta
    
    estimates_for_phi = data.frame(epsilon_index, d_index, 
                                   NAs_for_phi) # stores all estimates for phi
    
    for(i in 1:floor(replica/10)){
      # Monte Carlo simulation
      sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCCt(phi, 
                                                             eta, 
                                                             S, 
                                                             nobs, 
                                                             ndim, 
                                                             x + i*20
      )})
      
      # taking rt and ht from sim
      rt = map(sim, 1)
      ht = map(sim, 2)
      
      # contaminatinc series of returns
      seed = as.list(sqrt((i * 10 + 1) : (i * 10  + 10)))
      
      rt_list = list(mapply(contaminate1, rt, ht, seed, nday=0, 0, 
                            SIMPLIFY = FALSE), # epsilon=0%
                     mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 3,
                            SIMPLIFY = FALSE),  # epsilon=1%
                     mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 4,
                            SIMPLIFY = FALSE),  # epsilon=1%
                     mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 3,
                            SIMPLIFY = FALSE),  # epsilon=5%
                     mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 4,
                            SIMPLIFY = FALSE),   # epsilon=5%
                     mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 3,
                            SIMPLIFY = FALSE),   # epsilon=5%
                     mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4,
                            SIMPLIFY = FALSE)   # epsilon=5%
      )
      
      # estimation
      estimated = lapply(rt_list, estimatecDCC_by_list)
      
      est_eta = map(estimated, 1) %>% list.rbind(.) 
      est_phi = map(estimated, 2) %>% list.rbind(.) 
      
      # updating dataframe of all estimates
      index_for_update = ((i-1) * 70 + 1) : (i * 70)
      
      estimates_for_eta[index_for_update, -c(1,2)] = est_eta
      estimates_for_phi[index_for_update, -c(1,2)] = est_phi
      
      # checkpoint
      saveRDS(estimates_for_eta, file = filename[1])
      saveRDS(estimates_for_phi, file = filename[2])
      
      
      checkpoint = (i * 10) / replica * 100
      
      cat('\n', 'progress in ', checkpoint, '%', '\n')
      print(Sys.time())
      
    }
  }
  
  if(estimation == 'robust'){
    
    cat('\n', 'robust estimation!!', '\n')
    
    # index
    delta_index = rep(rep(c(0.99, 0.975, 0.95, 0.90), each = 70), 
                      floor(replica/10))
    
    d_index = rep(rep(rep(c(0, 3, 4, 3, 4, 3, 4), each=10), 4), 
                  floor(replica/10))
    
    epsilon_index = rep(rep(rep(c('0%', '1%', '1%', '5%', '5%', '10%', '10%'), 
                                each=10), 4), floor(replica/10)) %>% 
      factor(., levels = c("0%", "1%", "5%", "10%"))
    
    # reserving spaces for the estimates
    NAs_for_eta = matrix(NA, ncol = nrow(eta) * 5, nrow = length(delta_index))
    NAs_for_phi = matrix(NA, ncol = length(phi), nrow = length(delta_index))
    
    # dataframe of results
    estimates_for_eta = data.frame(epsilon_index, d_index, delta_index,
                                   NAs_for_eta) # stores all estimates for eta
    
    estimates_for_phi = data.frame(epsilon_index, d_index, delta_index, 
                                   NAs_for_phi) # stores all estimates for phi
    
    for(i in 1:floor(replica/10)){
      tryCatch({
        # Monte Carlo simulation
        sim = parLapply(cl=cl, 1:10, fun = function(x){simCDCCt(phi, eta, S, 
                                                               nobs, 
                                                               ndim, 
                                                               x + i * 20
        )})
        
        # taking rt and ht from sim
        rt = map(sim, 1)
        ht = map(sim, 2)
        
        # contaminating series of returns
        seed = as.list(sqrt((i * 10+1) : (i * 10  + 10)))
        
        rt_list = list(mapply(contaminate1, rt, ht, seed, nday=0, 0,
                              SIMPLIFY = FALSE), # epsilon=0%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 3,
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 4, 
                              SIMPLIFY = FALSE),  # epsilon=1%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 3, 
                              SIMPLIFY = FALSE),  # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 4, 
                              SIMPLIFY = FALSE),   # epsilon=5%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 3, 
                              SIMPLIFY = FALSE),   # epsilon=10%
                       mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4, 
                              SIMPLIFY = FALSE)   # epsilon=10%
        )
        
        # estimation
        # setting robust control
        rc_delta99 = c(1.0185, 1.0101, .99)
        rc_delta975 = c(1.0465, 1.0257, .975)
        rc_delta95 = c(1.0953, 1.0526, .95)
        rc_delta90 = c(1.2030, 1.111, .90)
        
        # estimating for all replicas
        estimated_delta99 = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta99)
        
        estimated_delta975 = lapply(rt_list, 
                                    robust_estimatecDCC_by_list, 
                                    rc_delta975)
        
        estimated_delta95 = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta95)
        
        estimated_delta90 = lapply(rt_list, 
                                   robust_estimatecDCC_by_list, 
                                   rc_delta90)
        
        # storing estimates of this iteration
        est_eta = c(map(estimated_delta99, 1),
                    map(estimated_delta975, 1),
                    map(estimated_delta95, 1),
                    map(estimated_delta90, 1)) %>% list.rbind(.) 
        
        est_phi = c(map(estimated_delta99, 2),
                    map(estimated_delta975, 2),
                    map(estimated_delta95, 2),
                    map(estimated_delta90, 2)) %>% list.rbind(.)
        
        # updating dataframe of all estimates
        index_for_update = ((i-1) * 280 + 1) : (i * 280)
        
        estimates_for_eta[index_for_update, -c(1,2,3)] = est_eta
        estimates_for_phi[index_for_update, -c(1,2,3)] = est_phi
        
        # checkpoint
        saveRDS(estimates_for_eta, file = filename[1])
        saveRDS(estimates_for_phi, file = filename[2])
        
        checkpoint = (i * 10) / replica * 100
        
        cat('\n', 'progress in ', checkpoint, '%', '\n')
        print(Sys.time())
      }, error = function(e){cat("ERROR :", 
                                 conditionMessage(e), '. iteration:', i, "\n")})
    }
  }
  
  stopCluster(cl)
  
  return(print('The End!'))
} 


complete_repCDCCt = function(phi, eta, nobs, ndim){
  
  selected_seed = c(77, 203, 355, 368, 506, 634, 704, 784, 886)
  
  checkpoint = i = 1
  cores = detectCores() # detecting number of cores in the PC
  cl = makeCluster(cores - 2)
  est_eta = est_phi = c() # stores estimates for each iteration
  
  # setting clusters for parallel
  clusterExport(cl,
                c(
                  "simCDCCt",
                  'contaminate1',
                  'rtruncnorm',
                  'rmvn',
                  'map',
                  '%>%',
                  'sqrtm'
                ))
  
  clusterExport(cl, c('phi',
                      'eta',
                      'S',
                      'nobs',
                      'ndim', 'i', 'selected_seed'), envir = environment())
  
  
  cat('\n', 'robust estimation!!', '\n')
  
  # index
  delta_index = rep(rep(c(0.99, 0.975, 0.95, 0.90), each = 70), 9)
  d_index = rep(rep(rep(c(0, 3, 4, 3, 4, 3, 4), each = 10), 4), 9)
  
  epsilon_index = rep(rep(rep(
    c('0%', '1%', '1%', '5%', '5%', '10%', '10%'),
    each = 10), 4), 9) %>%
    factor(., levels = c("0%", "1%", "5%", "10%"))
  
  # reserving spaces for the estimates
  NAs_for_eta = matrix(NA, ncol = nrow(eta) * 5, nrow = length(delta_index))
  NAs_for_phi = matrix(NA, ncol = length(phi), nrow = length(delta_index))
  
  # dataframe of results
  estimates_for_eta = data.frame(epsilon_index, d_index, delta_index,
                                 NAs_for_eta) # stores all estimates for eta
  
  estimates_for_phi = data.frame(epsilon_index, d_index, delta_index,
                                 NAs_for_phi) # stores all estimates for phi
  
  for (i in 1:9) {
    # Monte Carlo simulation
    sim = parLapply(
      cl = cl,
      1:10,
      fun = function(x) {
        simCDCCt(phi, eta, S,
                 nobs,
                 ndim,
                 x + selected_seed[i] * 20)
      }
    )
    
    # taking rt and ht from sim
    rt = map(sim, 1)
    ht = map(sim, 2)
    
    # contaminating series of returns
    seed = as.list(sqrt((selected_seed[i] * 10 + 1):(selected_seed[i] * 10  + 10)))
    
    rt_list = list(mapply(contaminate1, rt, ht, seed, nday=0, 0,
                          SIMPLIFY = FALSE), # epsilon=0%
                   mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 3,
                          SIMPLIFY = FALSE),  # epsilon=1%
                   mapply(contaminate1, rt, ht, seed, nday=.01 * nobs, 4, 
                          SIMPLIFY = FALSE),  # epsilon=1%
                   mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 3, 
                          SIMPLIFY = FALSE),  # epsilon=5%
                   mapply(contaminate1, rt, ht, seed, nday=.05 * nobs, 4, 
                          SIMPLIFY = FALSE),   # epsilon=5%
                   mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 3, 
                          SIMPLIFY = FALSE),   # epsilon=10%
                   mapply(contaminate1, rt, ht, seed, nday=.10 * nobs, 4, 
                          SIMPLIFY = FALSE)   # epsilon=10%
    )
    
    # estimation
    # setting robust control
    rc_delta99 = c(1.0185, 1.0101, .99)
    rc_delta975 = c(1.0465, 1.0257, .975)
    rc_delta95 = c(1.0953, 1.0526, .95)
    rc_delta90 = c(1.2030, 1.111, .90)
    
    # estimating for all replicas
    estimated_delta99 = lapply(rt_list,
                               robust_estimatecDCC_by_list,
                               rc_delta99)
    
    estimated_delta975 = lapply(rt_list,
                                robust_estimatecDCC_by_list,
                                rc_delta975)
    
    estimated_delta95 = lapply(rt_list,
                               robust_estimatecDCC_by_list,
                               rc_delta95)
    
    estimated_delta90 = lapply(rt_list,
                               robust_estimatecDCC_by_list,
                               rc_delta90)
    
    # storing estimates of this iteration
    est_eta = c(
      map(estimated_delta99, 1),
      map(estimated_delta975, 1),
      map(estimated_delta95, 1),
      map(estimated_delta90, 1)
    ) %>% list.rbind(.)
    
    est_phi = c(
      map(estimated_delta99, 2),
      map(estimated_delta975, 2),
      map(estimated_delta95, 2),
      map(estimated_delta90, 2)
    ) %>% list.rbind(.)
    
    # updating dataframe of all estimates
    index_for_update = ((i - 1) * 280 + 1):(i * 280)
    
    estimates_for_eta[index_for_update,-c(1, 2, 3)] = est_eta
    estimates_for_phi[index_for_update,-c(1, 2, 3)] = est_phi
    
    # checkpoint
    # saveRDS(estimates_for_eta, file = filename[1])
    # saveRDS(estimates_for_phi, file = filename[2])
    
    checkpoint = (i * 10) / 9 * 100
    
    cat('\n', 'progress in ', checkpoint, '%', '\n')
    print(Sys.time())
  }
  
  stopCluster(cl)
  
  return(list(garch = estimates_for_eta, cdcc=estimates_for_phi))
}



