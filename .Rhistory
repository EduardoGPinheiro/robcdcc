# chisq1 = qchisq(delta, 1)
# chisq2 = qchisq(delta, ndim)
# Calculating all Qs * epsilon
q_Qs = mapply(calc_Qs, q_phi, cont_data, SIMPLIFY = FALSE)
# r_Qs = mapply(robust_calc_Qs, r_phi, cont_data,
#               MoreArgs = list(cy1 = cy1, chisq1 = chisq1),
#               SIMPLIFY = FALSE)
# Getting real S
S = lapply(seeds, function(x){
set.seed(x * 10)
rho = truncnorm::rtruncnorm(
ndim,
a = .5 - 4 * .1,
b = .5 + 4 * .1,
mean = .5,
sd = .1
)
S = rho %o% rho
diag(S) = rep(1, ndim)
return(S)
})
# Non-Linear Shrinkage covariance estimate
print(Sys.time())
cat('\n', 'shrinkage!', '\n')
wrapper_q_S = parLapply(cl=cl, q_Qs, wrapper_cov)
# wrapper_r_S = parLapply(cl=cl, r_Qs, wrapper_cov)
q_S = parLapply(cl=cl, wrapper_q_S, my_nlshrink)
# r_S = parLapply(cl=cl, wrapper_r_S, my_nlshrink)
cat('\n', 'S determinant!', '\n')
q_S_determinant =  q_S %>% lapply(determinant) %>%
map(1) %>% lapply(function(x){return(x[1])}) %>%
unlist
# r_S_determinant =  r_S %>% lapply(determinant) %>%
#   map(1) %>% lapply(function(x){return(x[1])}) %>%
#   unlist
# Portfolio variance
print(Sys.time())
cat('\n', 'portfolio_var!', '\n')
# variance_portfolio = parLapply(
#   cl = cl,
#   1:10,
#   fun=function(x){
#     tryCatch(
#       geral_calc_portfolio_variance(phi=phi,
#                                     q_phi=q_phi[[x]],
#                                     r_phi=r_phi[[x]],
#                                     rt=data[[x]], burn_rt=bdata[[x]],
#                                     cont_rt=cont_data[[x]],
#                                     S=S[[x]],
#                                     q_S=q_S[[x]], r_S=r_S[[x]],
#                                     cy2=cy2, chisq2=chisq2)
#     )}
# )
variance_portfolio = parLapply(
cl = cl,
1:10,
fun=function(x){
tryCatch(
qmvn_calc_portfolio_variance(
phi = phi,
q_phi = q_phi[[x]],
rt = data[[x]],
burn_rt = bdata[[x]],
cont_rt = cont_data[[x]],
S = S[[x]],
q_S = q_S[[x]]
)
)}
)
results = lapply(variance_portfolio, t) %>%
rlist::list.rbind(.) %>% as.data.frame
results$q_S_determinant = q_S_determinant
results$r_S_determinant = r_S_determinant
results$d = d
results$consecutive = consecutive
results$epsilon = epsilon
results$seed = i
results$delta = delta
# biding results
results_path = paste(
'simulation_results/03__high_dimension_var_n1250/qmvn_portfolio_var/pt_', i, '_epsilon_',
epsilon, '_d_', d, '_consecutive_', consecutive,'.Rds', sep = "")
# checkpoint
saveRDS(results, file = results_path)
}, error = function(e){cat("ERROR :",
conditionMessage(e), '. iteration:', i, "\n")})
}
stopCluster(cl)
}
portfolio_var(estimates_groupby[[1]])
library(robcdcc)
library(robcdcc)
pt_4_epsilon_0.25_d_5_consecutive_FALSE <- readRDS("~/Documentos/Masters-degree/simulation_results/02__high_dimension/03__high_dimension_var_n1250/qmvn_portfolio_var/pt_4_epsilon_0.25_d_5_consecutive_FALSE.Rds")
pt_4_epsilon_0.25_d_5_consecutive_FALSE
library(robcdcc)
library(robcdcc)
library(robcdcc)
library(robcdcc)
'Estimate portfolio variance.'
# Packages
library(dplyr)
library(ggplot2)
library(rlist)
library(Metrics) # RMSE
library(purrr)
library(readr)
library(tidyr) # pivot_wider
library(data.table)
library(lemon) # shared subtitle for grid.arrange
library(miceadds) # source.all
library(Rcpp)
library(RcppArmadillo)
library(parallel)
library(robcdcc)
library(nlshrink)
library(readr)
library(cellWise)
# Paths
setwd("~/Documents/Masters-degree")
path = '02__bivariate/results'
# Functions
source('packages.R')
# Getting estimates
garch_estimates_df = read_delim(
file.path(path, "01__estimates/garch_estimates_df.csv"),
";",
escape_double = FALSE,
locale = locale(grouping_mark = "."),
trim_ws = TRUE
)
cdcc_estimates_df = read_delim(
file.path(path, "01__estimates/cdcc_estimates_df.csv"),
";",
escape_double = FALSE,
locale = locale(grouping_mark = "."),
trim_ws = TRUE
)
portfolio_var = function(garch_estimates, cdcc_estimates) {
d = cdcc_estimates$d[1]
delta = cdcc_estimates$delta[1]
epsilon = cdcc_estimates$epsilon[1]
ndim = 2
nobs = 2000
phi = c(.1, .8)
eta = matrix(
c(.1, .1, .8, .1, .2, .7),
ncol = 3,
nrow = 2,
byrow = TRUE
)
S = matrix(c(1, .4, .4, 1), ncol = 2, nrow = 2)
# Starting workers
cores = detectCores() # detecting number of cores in the PC
cl = makeCluster(cores - 2)
clusterEvalQ(cl, library("robcdcc"))
clusterEvalQ(cl, library("truncnorm"))
clusterEvalQ(cl, library("purrr"))
clusterExport(
cl,
c(
"high_dimension_estimateCDCC",
"case_when",
"optimCDCC",
"optimGARCH",
"simCDCC",
"loglikelihoodCDCC",
"loglikelihoodGARCH",
"gradientCDCC",
"robust_optimCDCC",
"robust_optimGARCH",
"robust_loglikelihoodCDCC",
"robust_loglikelihoodGARCH",
"robust_gradientCDCC",
"robust_estimateGARCH",
"robust_estimateCDCC",
"estimateGARCH",
"estimateCDCC",
"robust_gradientGARCH",
"medianB"
)
)
clusterExport(
cl,
c(
"%>%",
"geral_calc_portfolio_variance"
)
)
clusterExport(cl, c('phi', "nobs", "eta", "ndim", "S"), envir = environment())
# Simulation
for (i in 1:1000) {
tryCatch({
cat('\n', 'pt ', i, '\n')
print(Sys.time())
sim = parLapply(
cl = cl,
1:10,
fun = function(x) {
simCDCC(phi,
eta,
S,
nobs,
ndim,
x + i * 20)
}
)
# taking rt and ht from sim
rt = map(sim, 1)
ht = map(sim, 2)
burnin_std_rt = map(sim, 4)
std_rt = map(sim, 5)
# contaminating data
cont_seed = as.list(((i * 10 + 1):(i * 10  + 10)))
cont_data = mapply(
contaminate1,
rt,
ht,
cont_seed,
MoreArgs = list(d = d, epsilon = epsilon),
SIMPLIFY = FALSE
)
# Getting eta estimates
garch_estimates_i = garch_estimates[garch_estimates$seed == i,]
q_garch_estimates = garch_estimates_i %>% filter(model == 'Q') %>%
mutate(id = rep(1:(n() / 2), each = 2)) %>% group_by(id) %>%
group_split()
r_garch_estimates = garch_estimates_i %>% filter(model == 'R') %>%
mutate(id = rep(1:(n() / 2), each = 2)) %>% group_by(id) %>%
group_split()
# Calculating std residuals
q_garch_results = mapply(
calc_std_residuals,
rt = cont_data,
eta = q_garch_estimates,
SIMPLIFY = FALSE
)
r_garch_results = mapply(
calc_std_residuals,
rt = cont_data,
eta = r_garch_estimates,
SIMPLIFY = FALSE
)
q_std_rt = q_garch_results %>% map(1)
r_std_rt = r_garch_results %>% map(1)
# Get phi estimates
cdcc_estimates_i = cdcc_estimates[cdcc_estimates$seed == i,]
q_cdcc_estimates = cdcc_estimates_i %>% filter(model == 'Q')
r_cdcc_estimates = cdcc_estimates_i %>% filter(model == 'R')
q_phi = q_cdcc_estimates[, c('X1', 'X2')] %>%
split(., seq(nrow(.))) %>% lapply(as.numeric)
r_phi = r_cdcc_estimates[, c('X1', 'X2')] %>%
split(., seq(nrow(.)))  %>% lapply(as.numeric)
# Portfolio variance
robust_control = c(1.0465, 1.00045, .975)
cy1 = robust_control[1]
cy2 = robust_control[2]
delta = robust_control[3]
# quantile for chi square distribution
chisq1 = qchisq(delta, 1)
chisq2 = qchisq(delta, 2)
# Calculating all Qs * epsilon
q_Qs = mapply(calc_Qs,
phi = q_phi,
rt = q_std_rt,
SIMPLIFY = FALSE)
r_Qs = mapply(
robust_calc_Qs,
phi = r_phi,
rt = r_std_rt,
SIMPLIFY = FALSE
)
# Calculate S
q_S = lapply(q_Qs, cor)
r_S = lapply(r_Qs,
corr_reweighted_C,
chisq2 = chisq2,
cy2 = cy2)
# Get Dt
Dt = ht %>% lapply(function(x) {
x %>% tail(1) %>% sqrt %>% as.numeric %>% diag
})
q_Dt = q_garch_results %>% map(2) %>%
lapply(function(x) {
x %>% tail(1) %>% sqrt %>% as.numeric %>% diag
})
r_Dt = r_garch_results %>% map(2) %>%
lapply(function(x) {
x %>% tail(1) %>% sqrt %>% as.numeric %>% diag
})
# Portfolio variance
print(Sys.time())
cat('\n', 'portfolio_var!', '\n')
variance_portfolio = parLapply(
cl = cl,
1:10,
fun = function(x) {
tryCatch(
geral_calc_portfolio_variance(
phi = phi,
q_phi = q_phi[[x]],
r_phi = r_phi[[x]],
rt = std_rt[[x]],
burn_rt = burnin_std_rt[[x]],
cont_rt = cont_data[[x]],
S = S,
Dt = Dt[[x]],
q_Dt = q_Dt[[x]],
r_Dt = r_Dt[[x]],
q_S = q_S[[x]],
r_S = r_S[[x]],
cy2 = cy2,
chisq2 = chisq2
)
)
}
)
results = lapply(variance_portfolio, t) %>%
rlist::list.rbind(.) %>% as.data.frame
results$d = d
results$epsilon = epsilon
results$seed = i
results$delta = delta
# biding results
results_path = paste('02__portfolio_var/pt_',
i,
'_epsilon_',
epsilon,
'_d_',
d,
'.Rds',
sep = "")
# checkpoint
saveRDS(results, file = file.path(path, results_path))
}, error = function(e) {
cat("ERROR :",
conditionMessage(e), '. iteration:', i, "\n")
})
}
stopCluster(cl)
}
garch_estimates_groupby = garch_estimates_df %>%
group_by(d, epsilon) %>% group_split
cdcc_estimates_groupby = cdcc_estimates_df %>%
group_by(d, epsilon) %>% group_split
portfolio_var(garch_estimates=garch_estimates_groupby[[1]],
cdcc_estimates=cdcc_estimates_groupby[[1]])
'Bind all results into a single data frame and validate.'
# library(raster)
library(tidyverse)
library(remotes)
library(dplyr)
library(reshape2)
library(stringr)
library(testit)
# Path
path = '02__bivariate/results'
# Reading all robust estimates for Monte Carlo replica
estimates_files = list.files(
path = file.path(path, '01__estimates'),
pattern = "\\.Rds$",
full.names = TRUE
)
estimates_files
variance_files = list.files(
path = file.path(path, '02__portfolio_var'),
pattern = "\\.Rds$",
full.names = TRUE
)
variance_files
variance_df = lapply(variance_files, readRDS)
variance_df
variance_df = lapply(variance_files, readRDS) %>% rlist::list.rbind(.)
variance_df
# Portfolio variance ---- #
variance_df = lapply(variance_files, readRDS) %>% rlist::list.rbind(.) %>%
rename(vt_q = V1, vt_r = V2, fro_q = V3, fro_r = V4,
gmv_real = V5, gmv_q = V6, gmv_r = V7)
variance_df
# Portfolio variance ---- #
variance_df = lapply(variance_files, readRDS) %>% rlist::list.rbind(.) %>%
rename(vt_q = V1, vt_r = V2, fro_q = V3, fro_r = V4,
gmv_real = V5, gmv_q = V6, gmv_r = V7) %>%
mutate(gmv_q = gmv_q / gmv_real, gmv_r = gmv_r / gmv_real) %>%
select(-gmv_real)
variance_df
saveRDS(variance_df, file.path(path, 'biv_variance_df.Rds'))
path
saveRDS(variance_df, file.path(path, '02__portfolio_var/biv_variance_df.Rds'))
# Data loading
variance_df = readRDS(file.path(path, '02__portfolio_var/biv_variance_df.Rds'))
variance_df
variance_df
# Renaming values
variance_df = variance_df %>%
mutate(epsilon = recode(as.character(epsilon), '0' = '0 %'),
d = recode(as.character(d), '0' = 'd = 0'))
variance_df
long_variance_df = variance_df %>% melt(id_vars = c('epsilon', 'd', 'delta'))
long_variance_df
# Renaming values
variance_df = variance_df %>%
mutate(epsilon = recode(as.character(epsilon), '0' = '0 %'),
d = recode(as.character(d), '0' = 'd = 0')) %>%
select(-seed, -delta)
# Long format
long_variance_df = variance_df %>% melt(id_vars = c('epsilon', 'd', 'delta'))
long_variance_df
# Long format
variance_df_long = variance_df %>% melt(id_vars = c('epsilon', 'd', 'delta'))
# Box plot
box_plot = function(data){
p = data %>%
ggplot(aes(x = variable, y = value)) +
facet_wrap(consecutive ~ epsilon + d, nrow = 1) +
geom_boxplot() +
theme_half_open(12) +
background_grid() +
theme(
legend.position = 'none',
strip.background = element_blank(),
strip.text = element_textbox(
size = 12,
color = "white", fill = "gray23", box.color = "gray23",
halign = 0.5, linetype = 1, r = unit(5, "pt"), width = unit(1, "npc"),
padding = margin(2, 0, 1, 0), margin = margin(3, 3, 3, 3)
)
) + xlab('Modelo') + scale_x_discrete(label = c('Q', 'R')) + ylab(' ')
return(p)
}
p1 = variance_df_long %>% filter(str_detect(variable, 'vt')) %>% box_plot
library(ggplot2)
library(cowplot)
library(dplyr)
library(reshape2)
library(xtable)
library(ggpubr)
library(readr)
library(ggtext)
library(tidyverse)
library(magrittr)
p1 = variance_df_long %>% filter(str_detect(variable, 'vt')) %>% box_plot
p1
# Box plot
box_plot = function(data){
p = data %>%
ggplot(aes(x = variable, y = value)) +
facet_wrap(d ~ epsilon, nrow = 1) +
geom_boxplot() +
theme_half_open(12) +
background_grid() +
theme(
legend.position = 'none',
strip.background = element_blank(),
strip.text = element_textbox(
size = 12,
color = "white", fill = "gray23", box.color = "gray23",
halign = 0.5, linetype = 1, r = unit(5, "pt"), width = unit(1, "npc"),
padding = margin(2, 0, 1, 0), margin = margin(3, 3, 3, 3)
)
) + xlab('Modelo') + scale_x_discrete(label = c('Q', 'R')) + ylab(' ')
return(p)
}
p1 = variance_df_long %>% filter(str_detect(variable, 'vt')) %>% box_plot
p1
# Box plot
box_plot = function(data){
p = data %>%
ggplot(aes(x = variable, y = value)) +
facet_grid(d ~ epsilon) +
geom_boxplot() +
theme_half_open(12) +
background_grid() +
theme(
legend.position = 'none',
strip.background = element_blank(),
strip.text = element_textbox(
size = 12,
color = "white", fill = "gray23", box.color = "gray23",
halign = 0.5, linetype = 1, r = unit(5, "pt"), width = unit(1, "npc"),
padding = margin(2, 0, 1, 0), margin = margin(3, 3, 3, 3)
)
) + xlab('Modelo') + scale_x_discrete(label = c('Q', 'R')) + ylab(' ')
return(p)
}
p1 = variance_df_long %>% filter(str_detect(variable, 'vt')) %>% box_plot
p1
p2 = variance_df_long %>% filter(str_detect(variable, 'gmv')) %>% box_plot
p3 = variance_df_long %>% filter(str_detect(variable, 'fro')) %>% box_plot
p2
cdcc_estimates_groupby
# Portfolio variance ---- #
variance_df = lapply(variance_files, readRDS) %>% rlist::list.rbind(.) %>%
rename(vt_q = V1, vt_r = V2, fro_q = V3, fro_r = V4,
gmv_real = V5, gmv_q = V6, gmv_r = V7) %>%
mutate(gmv_q = gmv_q / gmv_real, gmv_r = gmv_r / gmv_real) %>%
select(-gmv_real)
renv::status()
renv::init()
renv::status()
renv::snapshot()
library(robcdcc)
renv::dependencies()
renv::hydrate()
renv::status()
renv::install('truncnorm')
renv::status()
library(truncnorm)
library(robcdcc)
renv::status()
renv::snapshot()
library(robcdcc)
library(robcdcc)
